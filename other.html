<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AWS Other Services — CloudFormation, Systems Manager, Batch, Pinpoint, and More</title>
    <link rel="stylesheet" href="./style.css">
</head>
<body>
    <div class="container2">
        <div class="header">
            <h1>AWS Other Services: Infrastructure Automation, Communications, and Operations</h1>
            <hr>
        </div>

        <h2>Overview</h2>
        <p>This section covers additional AWS services critical for Solutions Architects: infrastructure-as-code automation (CloudFormation), communications (SES, Pinpoint), systems management (Session Manager, Run Command, Patch Manager, Automation), cost optimization (Cost Explorer, Anomaly Detection, Instance Scheduler), batch processing (Batch), edge computing (Outposts), and application integration (AppFlow, Amplify). These services enable operational excellence, cost efficiency, and scalable deployments.</p>

        <hr class="soft-divide">
        <h2>AWS CloudFormation — Infrastructure as Code</h2>

        <h3>Service Overview</h3>
        <p>AWS CloudFormation is a declarative infrastructure-as-code service that enables you to define, provision, and manage AWS resources using templates. Instead of manually creating resources (clicking AWS Console), you describe your entire infrastructure in JSON or YAML. CloudFormation provisions, updates, and deletes resources based on your template. This approach provides version control, code review, automation, and repeatability for infrastructure.</p>

        <h3>Core Benefits</h3>
        <ul>
            <li><strong>Infrastructure as Code:</strong> Define infrastructure in version-controlled templates. No manual resource creation. Changes to infrastructure go through code review process (pull requests, approvals) before deployment. Entire deployment history tracked in Git.</li>
            <li><strong>Cost Visibility & Optimization:</strong> Each resource in a CloudFormation stack is tagged with a stack identifier. AWS Cost Explorer shows costs per stack, enabling cost allocation to projects/departments. Templates can include cost estimates before deployment. Easy to destroy stacks to stop incurring costs (no forgotten resources left behind).</li>
            <li><strong>Productivity & Speed:</strong> Destroy and recreate entire environments in minutes (dev/test environments). Automated diagram generation from templates (visual understanding of infrastructure). Declarative approach: describe desired state, CloudFormation handles provisioning order and dependencies.</li>
            <li><strong>Simplicity & Reusability:</strong> Leverage existing AWS CloudFormation templates from community, AWS Quick Starts, and documentation. No need to write from scratch. Modify templates for your use case (YAML is human-readable).</li>
            <li><strong>Broad Resource Support:</strong> CloudFormation supports 400+ AWS resources. For services without native CloudFormation support, use custom resources (invoke Lambda to provision 3rd-party services).</li>
        </ul>

        <h3>CloudFormation Stack Lifecycle</h3>
        <ul>
            <li><strong>Create:</strong> Submit template → CloudFormation provisions all resources → stack transitions to CREATE_COMPLETE.</li>
            <li><strong>Update:</strong> Modify template → CloudFormation updates existing resources (some require replacement, others in-place update) → stack transitions to UPDATE_COMPLETE.</li>
            <li><strong>Delete:</strong> Delete stack → CloudFormation deletes all resources → stack transitions to DELETE_COMPLETE (resource cleanup prevents forgotten costs).</li>
            <li><strong>Rollback:</strong> If stack creation/update fails, CloudFormation automatically rolls back to previous state (prevents partial/broken stacks).</li>
        </ul>

        <h3>CloudFormation Service Role</h3>
        <p>A CloudFormation Service Role is an IAM role that allows CloudFormation to create, update, and delete stack resources on your behalf. This enables separation of permissions and least-privilege principle.</p>
        <ul>
            <li><strong>Use Case:</strong> A developer should be able to deploy stacks but shouldn't have direct IAM permissions to create/modify all resources. Solution: Create IAM role with permissions to create required resources. Developer gets only iam:PassRole permission (can assume the role) and cloudformation:CreateStack/UpdateStack permissions. CloudFormation assumes the service role and provisions resources using that role's permissions.</li>
            <li><strong>Least Privilege:</strong> Service role has minimal permissions (only resources needed for the stack). If stack is compromised, attacker is limited to role's permissions, not developer's broader permissions.</li>
            <li><strong>Requirement:</strong> User deploying stack must have iam:PassRole permission to use the service role.</li>
        </ul>

        <h3>Exam Questions & Answers</h3>

        <ol>
            <li>
                <strong>Q: Your organization wants to provision a complete VPC, EC2 instances, RDS database, and load balancer in one operation. How would you automate this deployment for repeatability and version control?</strong>
                <br><br>
                <strong>A:</strong> Use AWS CloudFormation. Create a CloudFormation template (YAML/JSON) defining all resources (VPC, subnets, security groups, EC2 instances, RDS, ELB). Store template in Git for version control. Deploy via CloudFormation create-stack → all resources provisioned in correct order. To redeploy: same template, new stack name. To update: modify template, update-stack. To destroy: delete-stack removes all resources (prevents cost leakage). Alternative: Terraform also works, but CloudFormation is AWS-native.
            </li>

            <li>
                <strong>Q: A developer accidentally has permissions to delete production RDS instances. How would you prevent this using CloudFormation?</strong>
                <br><br>
                <strong>A:</strong> Use CloudFormation Service Role with limited permissions. (1) Create IAM service role with permissions to create/update RDS but NOT delete RDS. (2) Developer gets iam:PassRole + cloudformation:CreateStack/UpdateStack/DeleteStack. (3) When developer deploys CloudFormation stack, CloudFormation assumes service role (limited permissions). (4) Developer can deploy/update stacks, but cannot directly delete RDS (no permission in service role). (5) Stack deletion requires approval process (manual gate, requires different role with delete permissions). This separates operational deployments (automatic, developer-triggered) from destructive operations (manual, approval-required).
            </li>

            <li>
                <strong>Q: Your organization wants to track infrastructure costs by project. You have 50 stacks deployed. How would you allocate costs to projects using CloudFormation?</strong>
                <br><br>
                <strong>A:</strong> Tag all CloudFormation stacks with project metadata (ProjectName, CostCenter, Owner tags). All resources in stack automatically inherit stack tags. AWS Cost Explorer filters costs by tags → "Show costs by ProjectName tag" → breakdown of costs per project. CloudFormation template can include AWS::CloudFormation::Stack metadata with project information. Billing reports can be filtered by stack tags. This enables cost allocation to departments/projects and cost chargeback models.
            </li>
        </ol>

        <hr class="soft-divide">
        <h2>Amazon SES (Simple Email Service)</h2>

        <h3>Service Overview</h3>
        <p>Amazon SES is a fully managed email service for sending and receiving emails at scale, globally, and securely. It's ideal for transactional emails (password resets, order confirmations) and bulk marketing emails. SES is highly reliable (99.9% uptime) and provides detailed deliverability insights.</p>

        <h3>Key Features</h3>
        <ul>
            <li><strong>Outbound & Inbound Email:</strong> Send emails to users (transactional, marketing). Receive emails (support tickets, form submissions) and route to backend systems via Lambda/SQS.</li>
            <li><strong>Email Delivery Reputation:</strong> Reputation dashboard shows deliverability metrics. Tracks bounces, complaints, rejections. Poor reputation (high bounce rate) can result in sending limits being reduced. Best practices (opt-in lists, authentication) maintain good reputation.</li>
            <li><strong>Anti-Spam Feedback Loop:</strong> If recipient marks email as spam, SES notifies you (via SNS). Automatically unsubscribe users who mark emails as spam.</li>
            <li><strong>Email Authentication:</strong> Supports DKIM (DomainKeys Identified Mail) and SPF (Sender Policy Framework) to prevent spoofing and improve deliverability. Configure DNS records to enable authentication.</li>
            <li><strong>Flexible IP Deployment:</strong>
                <ul>
                    <li><strong>Shared IP:</strong> Default. Share IP with other SES users. Good for starting out; no IP warm-up needed.</li>
                    <li><strong>Dedicated IP:</strong> Your own IP address. Control reputation. Requires IP warm-up (gradual increase in sending volume) to establish good reputation. Better for high-volume senders.</li>
                    <li><strong>Customer-Owned IP:</strong> Use your own IP address (advanced setup).</li>
                </ul>
            </li>
            <li><strong>Sending Methods:</strong> AWS Console, APIs (SendEmail, SendBulkTemplatedEmail), SMTP protocol. Integrate with applications via SDK.</li>
            <li><strong>Email Templates:</strong> Create reusable templates with variables (personalization). Template syntax: {{variable_name}} replaced at send time.</li>
        </ul>

        <h3>Exam Questions & Answers</h3>

        <ol>
            <li>
                <strong>Q: Your e-commerce platform sends password reset emails to users. Some emails are not being delivered (landing in spam). How would you improve email deliverability using SES?</strong>
                <br><br>
                <strong>A:</strong> (1) Enable DKIM and SPF authentication: Configure DNS records to authenticate emails. SES provides DKIM tokens and SPF record to add to DNS. (2) Monitor reputation: SES Reputation Dashboard shows bounce/complaint rates. Investigate why emails are bouncing (invalid addresses, spam complaints). (3) Use list verification: Verify email addresses before sending (SES can validate). Remove bounced/complained addresses from future sends. (4) Sender domain verification: Verify the "from" domain in SES. (5) Track metrics: CloudWatch tracks sends, bounces, complaints. Set alarms for high bounce rates. (6) Use dedicated IP if volume is high: Establish your own IP reputation separate from other senders.
            </li>

            <li>
                <strong>Q: You need to send bulk marketing emails (newsletters) to 100,000 subscribers weekly. How would you configure SES for this scale?</strong>
                <br><br>
                <strong>A:</strong> (1) Request production access (SES starts in sandbox mode with 1 email/second limit; production removes limit). (2) Use SendBulkTemplatedEmail API (optimized for bulk sending). (3) Request increase to 14 emails/second sending rate (or negotiate higher). (4) Use dedicated IP for high volume to control reputation. (5) Segment list by engagement: send to engaged users more frequently, inactive users less often (improves metrics). (6) Monitor bounce/complaint rates via CloudWatch. (7) Implement list hygiene: immediately unsubscribe users who mark as spam (feedback loop). (8) Use SES email templates with personalization variables ({{customer_name}}, {{discount_code}}).
            </li>

            <li>
                <strong>Q: Your application receives customer support emails at support@mycompany.com. You want to process these emails (extract ticket info, route to support team). How would you integrate SES inbound capability?</strong>
                <br><br>
                <strong>A:</strong> (1) Set up SES email receiving: Configure SES to receive emails to your domain. Add MX records to route incoming emails to SES. (2) Create SES receipt rule set: Define rules for incoming emails. (3) Route emails to Lambda/SNS: When email arrives, SES can trigger Lambda (parse email, extract info, create support ticket in database) or send to SNS topic (notify support team). (4) Store email metadata in DynamoDB or RDS for tracking. (5) Optionally send auto-reply via SES SendEmail API. This creates a fully automated support ticket system.
            </li>
        </ol>

        <hr class="soft-divide">
        <h2>Amazon Pinpoint</h2>

        <h3>Service Overview</h3>
        <p>Amazon Pinpoint is a scalable, two-way marketing communications service for sending personalized, segmented messages via email, SMS, push notifications, voice, and in-app messaging. Unlike SNS (one-way notifications), Pinpoint enables reply/feedback, segmentation, and campaign orchestration. It scales to billions of messages per day with detailed analytics.</p>

        <h3>Key Capabilities</h3>
        <ul>
            <li><strong>Multi-Channel Messaging:</strong> Email, SMS, push notifications (mobile apps), voice calls, in-app messaging. Unified platform for all communication channels.</li>
            <li><strong>Segmentation & Personalization:</strong> Segment audiences based on attributes (age, location, purchase history, engagement). Send targeted campaigns with personalized content (name, recommendations, offers). Improve conversion and engagement.</li>
            <li><strong>Bi-Directional Communication:</strong> Customers can reply to SMS/voice messages. Pinpoint captures replies and routes to backend (SNS, Lambda, Kinesis). Enable conversational marketing (customer responds, system reacts).</li>
            <li><strong>Campaign Management:</strong> Design campaigns visually. Define journey (email → wait 3 days → SMS → wait 7 days → push). Schedule campaigns on specific dates/times or trigger on events (user signup, purchase).</li>
            <li><strong>Analytics & Insights:</strong> Track delivery, opens, clicks, conversions. A/B test messages (variant A vs B). Optimize based on engagement metrics.</li>
            <li><strong>Scale:</strong> Handles billions of messages per day. Automatically scales without manual intervention.</li>
        </ul>

        <h3>Use Cases</h3>
        <ul>
            <li><strong>Marketing Campaigns:</strong> Send targeted promotions, discounts, seasonal offers to customer segments.</li>
            <li><strong>Transactional SMS:</strong> Order confirmations, shipping updates, appointment reminders. Bulk SMS at scale.</li>
            <li><strong>Retention Campaigns:</strong> Re-engagement campaigns for inactive users. Win-back offers via email/SMS.</li>
            <li><strong>Push Notifications:</strong> In-app messages for mobile apps (new feature announcements, reminders).</li>
            <li><strong>Exam Pattern:</strong> "Send personalized SMS campaigns to millions of customers" → Pinpoint (SES is email-focused, SNS is simple notifications).</li>
        </ul>

        <hr class="soft-divide">
        <h2>SNS vs SES vs Pinpoint — Comparison Table</h2>
        <table style="width:100%; border-collapse:collapse; margin:10px 0;">
            <tr style="background:#f0f0f0;">
                <th style="border:1px solid #ddd; padding:8px; text-align:left;">Aspect</th>
                <th style="border:1px solid #ddd; padding:8px; text-align:left;">SNS</th>
                <th style="border:1px solid #ddd; padding:8px; text-align:left;">SES</th>
                <th style="border:1px solid #ddd; padding:8px; text-align:left;">Pinpoint</th>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Primary Purpose</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">Simple one-way notifications (alerts, events)</td>
                <td style="border:1px solid #ddd; padding:8px;">Transactional & bulk emails</td>
                <td style="border:1px solid #ddd; padding:8px;">Personalized multi-channel marketing campaigns</td>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Communication Channels</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">Email, SMS, HTTPS, SQS, Lambda</td>
                <td style="border:1px solid #ddd; padding:8px;">Email (send & receive)</td>
                <td style="border:1px solid #ddd; padding:8px;">Email, SMS, push, voice, in-app</td>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Bi-Directional</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">No (topic subscribers receive)</td>
                <td style="border:1px solid #ddd; padding:8px;">Yes (receive replies via SES)</td>
                <td style="border:1px solid #ddd; padding:8px;">Yes (capture replies, responses)</td>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Segmentation</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">No (send to all subscribers)</td>
                <td style="border:1px solid #ddd; padding:8px;">No (manual list management)</td>
                <td style="border:1px solid #ddd; padding:8px;">Yes (audience segments, attributes)</td>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Personalization</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">No (template variables possible)</td>
                <td style="border:1px solid #ddd; padding:8px;">Basic (templates with variables)</td>
                <td style="border:1px solid #ddd; padding:8px;">Advanced (dynamic content, A/B testing)</td>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Campaign Management</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">No (triggered via code)</td>
                <td style="border:1px solid #ddd; padding:8px;">No (send via API/Console)</td>
                <td style="border:1px solid #ddd; padding:8px;">Yes (visual campaign builder, journeys)</td>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Analytics</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">Basic (messages published/delivered)</td>
                <td style="border:1px solid #ddd; padding:8px;">Good (bounce, complaint rates, delivery)</td>
                <td style="border:1px solid #ddd; padding:8px;">Advanced (delivery, opens, clicks, conversions)</td>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Use Case</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">System alerts, CloudWatch alarms, events</td>
                <td style="border:1px solid #ddd; padding:8px;">Password resets, order confirmations, newsletters</td>
                <td style="border:1px solid #ddd; padding:8px;">Marketing campaigns, customer retention, multi-channel outreach</td>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Exam Pattern</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">"Alert operations team" → SNS</td>
                <td style="border:1px solid #ddd; padding:8px;">"Send password reset emails" → SES</td>
                <td style="border:1px solid #ddd; padding:8px;">"Target SMS to inactive customers" → Pinpoint</td>
            </tr>
        </table>

        <hr class="soft-divide">
        <h2>AWS Systems Manager (SSM) — Operations & Management</h2>

        <h3>SSM Session Manager</h3>
        <p><strong>Session Manager</strong> enables secure shell access to EC2 instances and on-premises servers via AWS Console or CLI without SSH, bastion hosts, or SSH keys. Supports Windows (RDP), Linux, and macOS. Logs all sessions to S3 for audit compliance. Eliminates port 22 (SSH) exposure.</p>
        <ul>
            <li><strong>How It Works:</strong> EC2 instance must have SSM agent (installed by default on most AWS AMIs). Session Manager uses IAM for authentication (no SSH keys needed). Session data encrypted via TLS.</li>
            <li><strong>Use Case:</strong> Secure access to bastion hosts or application servers without public IP addresses. No need to manage SSH keys. Audit trail: all commands logged.</li>
            <li><strong>IAM Control:</strong> Grant/deny access via IAM policies. User must have ssm:StartSession permission.</li>
        </ul>

        <h3>SSM Run Command</h3>
        <p><strong>Run Command</strong> executes commands or documents across multiple EC2 instances (or on-premises servers) without SSH. No port 22 needed. Output sent to S3 or CloudWatch Logs. Integrated with IAM and CloudTrail for audit.</p>
        <ul>
            <li><strong>Use Cases:</strong> Patch instances, install software, configure security settings across hundreds of instances simultaneously. Run compliance checks and generate reports.</li>
            <li><strong>Resource Groups:</strong> Target instances by tags (e.g., "Environment=Production", "Team=Backend") → command runs on all matching instances.</li>
            <li><strong>Triggering:</strong> Manual (AWS Console/CLI), EventBridge rules (on-event or scheduled), AWS Config for remediation.</li>
            <li><strong>Exam Pattern:</strong> "Execute patching script on 100 EC2 instances" → SSM Run Command with resource group targeting by tag.</li>
        </ul>

        <h3>SSM Patch Manager</h3>
        <p><strong>Patch Manager</strong> automates the process of patching managed instances (EC2 and on-premises). Supports OS updates (Windows, Linux, macOS), application updates, and security patches. Compliant with compliance frameworks (CIS Benchmarks).</p>
        <ul>
            <li><strong>Patch Groups:</strong> Create groups of instances to patch together. Example: "WebServers", "Databases", "DesktopComputers".</li>
            <li><strong>Patch Policies:</strong> Define which patches to apply. Examples: Apply all security patches, apply Windows critical updates only, exclude specific applications.</li>
            <li><strong>Scheduling:</strong> Patch on-demand or on schedule using SSM Maintenance Windows (e.g., "patch every Sunday at 2 AM", "patch on the 2nd Tuesday of the month").</li>
            <li><strong>Compliance Reports:</strong> Patch Compliance dashboard shows which instances are up-to-date, which need patching, which failed.</li>
            <li><strong>Exam Pattern:</strong> "Automate patching across 500 EC2 instances on a monthly schedule" → SSM Patch Manager.</li>
        </ul>

        <h3>SSM Maintenance Windows</h3>
        <p><strong>Maintenance Windows</strong> define a schedule for performing maintenance actions on instances. You specify a recurrence (daily, weekly, monthly, or cron expression), duration window, and allowed actions (patching, updates, software installation).</p>
        <ul>
            <li><strong>Use Cases:</strong> Schedule patching for low-traffic hours (Sunday 2-4 AM). Schedule database maintenance (backup, index rebuild) weekly. Schedule log rotation on file servers.</li>
            <li><strong>Automation:</strong> Actions can be Run Command, Lambda invocations, or custom scripts.</li>
        </ul>

        <h3>SSM Automation</h3>
        <p><strong>Automation</strong> simplifies common maintenance and deployment tasks by automating workflows. You define automation runbooks (SSM Documents) that execute actions. Can be triggered manually, by EventBridge, or on schedule.</p>
        <ul>
            <li><strong>Common Automations:</strong>
                <ul>
                    <li>Restart multiple instances at once.</li>
                    <li>Create Amazon Machine Image (AMI) from running instance.</li>
                    <li>Create EBS snapshots for backup.</li>
                    <li>Remediate AWS Config rule violations (auto-fix non-compliant resources).</li>
                    <li>Scale Auto Scaling Group up/down based on conditions.</li>
                </ul>
            </li>
            <li><strong>Runbook:</strong> YAML/JSON document defining steps. Each step calls AWS service API (EC2, Lambda, etc.). Steps can be conditional (if X, do Y).</li>
            <li><strong>Triggering:</strong> AWS Console, CLI, EventBridge (event-based or schedule), AWS Config rule remediation.</li>
            <li><strong>Exam Pattern:</strong> "When CloudWatch alarm triggers (high memory), automatically restart EC2 instance" → SSM Automation triggered by EventBridge from CloudWatch alarm.</li>
        </ul>

        <hr class="soft-divide">
        <h2>AWS Batch</h2>

        <h3>Service Overview</h3>
        <p>AWS Batch is a fully managed batch processing service for running large-scale, compute-intensive jobs (100,000+ jobs) efficiently. Jobs run as Docker containers on EC2 or Spot instances. Batch automatically provisions the right amount of compute/memory for each job and removes idle resources. Ideal for scientific computing, rendering, data processing pipelines, and financial modeling.</p>

        <h3>Key Concepts</h3>
        <ul>
            <li><strong>Batch Job:</strong> A job with a defined start and end (unlike long-running services). Examples: process 1000 images (convert to thumbnail), simulate 10,000 financial scenarios, render 100 frames of animation.</li>
            <li><strong>Dynamic Scaling:</strong> As jobs arrive, Batch launches EC2 instances (or buys Spot instances). As jobs complete, instances terminate. You pay only for compute used, not idle infrastructure.</li>
            <li><strong>Docker Containers:</strong> Jobs packaged as Docker images (pushed to ECR). Batch runs images on ECS-managed EC2 instances.</li>
            <li><strong>Provisioning:</strong> Batch manages EC2 instance provisioning, termination, and capacity. You define job queue and compute environment (which instance types to use, on-demand vs spot percentage).</li>
            <li><strong>Scheduling:</strong> Submit jobs to queue. Batch schedules them based on available capacity and job priority. Failed jobs can auto-retry.</li>
        </ul>

        <h3>Lambda vs AWS Batch — Comparison Table</h3>
        <table style="width:100%; border-collapse:collapse; margin:10px 0;">
            <tr style="background:#f0f0f0;">
                <th style="border:1px solid #ddd; padding:8px; text-align:left;">Aspect</th>
                <th style="border:1px solid #ddd; padding:8px; text-align:left;">AWS Lambda</th>
                <th style="border:1px solid #ddd; padding:8px; text-align:left;">AWS Batch</th>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Execution Time Limit</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">Max 15 minutes</td>
                <td style="border:1px solid #ddd; padding:8px;">No limit (days if needed)</td>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Supported Runtimes</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">Limited (Python, Java, Node.js, Go, C#, Ruby)</td>
                <td style="border:1px solid #ddd; padding:8px;">Any language (Docker container)</td>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Temporary Disk Space</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">512 MB /tmp (limited)</td>
                <td style="border:1px solid #ddd; padding:8px;">EBS volumes and instance store (unlimited)</td>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Memory Allocation</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">128 MB - 10 GB</td>
                <td style="border:1px solid #ddd; padding:8px;">Any EC2 instance type (1 GB - 1 TB+)</td>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>CPU Access</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">Shared/limited CPU</td>
                <td style="border:1px solid #ddd; padding:8px;">Full EC2 instance CPU (multi-core)</td>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Scaling Model</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">Automatic (per-invocation)</td>
                <td style="border:1px solid #ddd; padding:8px;">Automatic (per-job, cost-optimized)</td>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Cost Model</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">Per-invocation + compute time (GB-seconds)</td>
                <td style="border:1px solid #ddd; padding:8px;">EC2 instance costs (on-demand or Spot)</td>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Use Case</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">API handlers, event processors, short-lived tasks</td>
                <td style="border:1px solid #ddd; padding:8px;">Long-running batch jobs, heavy compute, legacy apps</td>
            </tr>
            <tr>
                <td style="border:1px solid #ddd; padding:8px;"><strong>Exam Pattern</strong></td>
                <td style="border:1px solid #ddd; padding:8px;">"Process image in < 5 minutes" → Lambda</td>
                <td style="border:1px solid #ddd; padding:8px;">"Process 10,000 images, each takes 30 mins" → Batch</td>
            </tr>
        </table>

        <h3>Batch Use Cases</h3>
        <ul>
            <li><strong>Scientific Computing:</strong> Run 100,000 simulations (each takes 1 hour). Batch provisions EC2 instances, runs jobs in parallel, cleans up when done.</li>
            <li><strong>Data Processing:</strong> ETL pipelines that process large datasets (GB-TB). Example: process daily transaction logs, clean data, load to data warehouse.</li>
            <li><strong>Rendering:</strong> Animation studios render frames (each frame render takes 2-10 hours). Batch submits thousands of render jobs, automatically scales compute.</li>
            <li><strong>Financial Modeling:</strong> Monte Carlo simulations, risk analysis (thousands of scenarios, each computationally expensive).</li>
        </ul>

        <hr class="soft-divide">
        <h2>AWS AppFlow</h2>

        <h3>Service Overview</h3>
        <p>AWS AppFlow is a fully managed integration service that securely transfers data between Software-as-a-Service (SaaS) applications and AWS services. No custom integration code needed. Supports 40+ SaaS apps as sources and AWS services as destinations. Data flows can be scheduled, event-triggered, or on-demand. Includes built-in data transformation capabilities.</p>

        <h3>Supported Integrations</h3>
        <ul>
            <li><strong>SaaS Sources:</strong> Salesforce, SAP, Zendesk, Slack, ServiceNow, HubSpot, Marketo, Amplitude, and more.</li>
            <li><strong>AWS Destinations:</strong> S3, Redshift, DynamoDB, Kinesis, Lambda, Snowflake, SaaS destinations (Salesforce, Zendesk, etc.).</li>
        </ul>

        <h3>Key Features</h3>
        <ul>
            <li><strong>Data Flow Triggers:</strong> On schedule (e.g., daily), event-based (on-demand), or manual.</li>
            <li><strong>Data Transformation:</strong> Built-in mappings, filtering, validation. Transform SaaS data before loading to AWS.</li>
            <li><strong>Encryption:</strong> Data encrypted in transit (TLS) and at rest. Supports AWS PrivateLink for private connectivity.</li>
            <li><strong>Error Handling:</strong> Automatic retry logic, dead-letter queue for failed records.</li>
        </ul>

        <h3>Use Cases</h3>
        <ul>
            <li><strong>Customer Data Consolidation:</strong> Sync Salesforce customer data → S3 data lake. Consolidate data from multiple SaaS apps for analytics.</li>
            <li><strong>Data Enrichment:</strong> Pull data from external SaaS (Marketo leads) → Redshift → combine with internal customer data → insights.</li>
            <li><strong>Process Automation:</strong> Slack message (new customer signup) → Lambda trigger → fetch Salesforce account details → send email via SES.</li>
            <li><strong>Exam Pattern:</strong> "Sync Salesforce opportunities to S3 daily for analytics" → AppFlow (no code needed).</li>
        </ul>

        <hr class="soft-divide">
        <h2>AWS Amplify</h2>

        <h3>Service Overview</h3>
        <p>AWS Amplify is a set of tools and services for developing and deploying scalable full-stack web and mobile applications quickly. It includes: Amplify Hosting (git-based deployment), Amplify Libraries (SDKs for auth, API, storage), Amplify Console (visual app configuration), and Amplify Studio (UI builder).</p>

        <h3>Key Features</h3>
        <ul>
            <li><strong>Git Integration:</strong> Connect GitHub, GitLab, Bitbucket repository. On every push to main/develop branch, Amplify automatically builds and deploys.</li>
            <li><strong>CI/CD Pipeline:</strong> Automated build, test, deploy pipeline. Build logs in Amplify Console.</li>
            <li><strong>Backend Services:</strong> Easily add authentication (Amazon Cognito), APIs (AppSync/GraphQL), file storage (S3), databases (DynamoDB, RDS).</li>
            <li><strong>Hosting:</strong> Deploy front-end to CloudFront globally distributed CDN. HTTPS/TLS automatic.</li>
            <li><strong>Analytics:</strong> Built-in analytics tracking (page views, user engagement) via Amplitude integration.</li>
            <li><strong>Use Case:</strong> Deploy React/Vue/Angular web app from GitHub push in minutes. Amplify handles infrastructure, CI/CD, hosting.</li>
        </ul>

        <hr class="soft-divide">
        <h2>Cost Management & Optimization</h2>

        <h3>AWS Cost Explorer</h3>
        <p><strong>Cost Explorer</strong> enables you to visualize, understand, and manage AWS costs and usage over time. Create custom reports, filter by service, region, tag, or dimension. Forecast costs up to 12 months into the future.</p>
        <ul>
            <li><strong>Use Cases:</strong> Track costs per project (use tags), identify cost drivers (which services cost most), forecast budget needs, identify cost optimization opportunities (idle resources, oversized instances).</li>
        </ul>

        <h3>AWS Cost Anomaly Detection</h3>
        <p><strong>Anomaly Detection</strong> uses machine learning to continuously monitor your costs and usage. It learns your historical spending patterns and alerts you when spending deviates unusually. Prevents surprise bills from accidental resource over-provisioning or compromise.</p>
        <ul>
            <li><strong>Example:</strong> "Your daily EC2 costs are typically $100. Yesterday they spiked to $500 (detected anomaly). Alert: possible compromised instance running crypto-miner."</li>
        </ul>

        <hr class="soft-divide">
        <h2>AWS Outposts</h2>

        <h3>Service Overview</h3>
        <p>AWS Outposts is a fully managed service that extends AWS infrastructure, services, APIs, and tools to your on-premises data center. AWS delivers, installs, and manages Outpost server racks in your facility. You gain the same AWS experience on-premises (Ec2, RDS, S3, etc.) as in the cloud.</p>

        <h3>Key Benefits</h3>
        <ul>
            <li><strong>Low-Latency Access:</strong> Run compute on-premises for applications requiring microsecond latency to local systems.</li>
            <li><strong>Local Data Processing:</strong> Process sensitive data without transmitting to cloud. Meets data residency requirements (GDPR, HIPAA).</li>
            <li><strong>Fully Managed:</strong> AWS handles patching, updates, support. You don't manage hardware.</li>
            <li><strong>Easy Migration:</strong> Same AWS APIs, tools, experience. Migrate from on-premises to Outposts with minimal code changes. Later extend to cloud.</li>
            <li><strong>Responsibility:</strong> You responsible for Outpost rack physical security (building, power, cooling).</li>
        </ul>

        <h3>Use Cases</h3>
        <ul>
            <li>Large enterprises extending data center capacity to AWS without building new facilities.</li>
            <li>Manufacturing: Real-time latency-critical control systems running on-premises.</li>
            <li>Healthcare: Processing patient data on-premises (HIPAA compliance), extending to cloud for analytics.</li>
            <li>Financial: Real-time trading systems on-premises, connected to AWS for broader analytics.</li>
        </ul>

        <hr class="soft-divide">
        <h2>Instance Scheduler on AWS</h2>

        <h3>Service Overview</h3>
        <p>Instance Scheduler is an AWS solution (CloudFormation template) that automatically starts and stops EC2 instances, RDS instances, and Auto Scaling Groups on a schedule. Reduces infrastructure costs by up to 70% by stopping non-production instances outside business hours (weekends, nights).</p>

        <h3>How It Works</h3>
        <ul>
            <li><strong>Architecture:</strong> Lambda function runs on schedule (CloudWatch Events/EventBridge). Lambda reads schedules from DynamoDB table. For each resource tagged with schedule, Lambda calls EC2/RDS APIs to start/stop.</li>
            <li><strong>Tagging:</strong> Tag EC2 instances and RDS with a schedule tag (e.g., "schedule=BusinessHours", "schedule=Dev"). Scheduler reads tag and applies appropriate start/stop times.</li>
            <li><strong>Schedules:</strong> Define in DynamoDB: "BusinessHours" = start 8 AM weekdays, stop 6 PM weekdays, stop all day weekends.</li>
            <li><strong>Cross-Account & Cross-Region:</strong> Central scheduler account can stop instances in multiple AWS accounts and regions.</li>
        </ul>

        <h3>Cost Savings Example</h3>
        <ul>
            <li><strong>Dev/Test EC2 instance:</strong> Runs 24/7 costs $0.05/hour × 730 hours/month = $36.50/month.</li>
            <li><strong>With Scheduler:</strong> Stops from 6 PM - 8 AM (14 hours) and all weekend = 10 hours/weekday × 5 + 48 weekend hours = 98 hours/week ≈ 392 hours/month. Costs $0.05 × 338 hours (running time) = $16.90/month.</li>
            <li><strong>Savings:</strong> $36.50 - $16.90 = $19.60/month per instance (~54% savings).</li>
            <li><strong>For 100 dev instances:</strong> $1,960/month savings (~$23,520/year).</li>
        </ul>

        <h3>Supported Resources</h3>
        <ul>
            <li>EC2 instances (on/off)</li>
            <li>RDS instances (start/stop for compatible instance types)</li>
            <li>Auto Scaling Groups (adjust desired capacity)</li>
        </ul>

        <hr class="soft-divide">
        <h2>Exam-Style Scenarios</h2>

        <ol>
            <li>
                <strong>Q: Your organization runs 500 EC2 instances (dev/test/prod). You want to reduce costs by automatically stopping non-production instances outside business hours. How would you implement this?</strong>
                <br><br>
                <strong>A:</strong> Use Instance Scheduler. Deploy CloudFormation template which creates: (1) Lambda function to start/stop instances, (2) DynamoDB table for schedules, (3) EventBridge rules to trigger Lambda on schedule. Tag instances with schedule metadata (e.g., "schedule=BusinessHours"). Define schedules in DynamoDB (start 8 AM weekdays, stop 6 PM weekdays, stop all weekend). Scheduler automatically starts/stops instances based on tags. Estimated savings: 50-70% reduction in EC2 costs for dev/test instances.
            </li>

            <li>
                <strong>Q: You need to validate all production EC2 instances have a specific security configuration. How would you automate this check and remediation?</strong>
                <br><br>
                <strong>A:</strong> Combine AWS Config + SSM Automation. (1) AWS Config rule: checks if instances have required security group rule (e.g., SSH only from bastion). (2) If non-compliant, Config rule triggers SSM Automation via EventBridge. (3) Automation runbook runs SSM Run Command on non-compliant instance to apply security configuration (e.g., modify security group rule). (4) Instance auto-remediated without manual intervention. (5) Config dashboard shows compliance status.
            </li>

            <li>
                <strong>Q: Your batch processing pipeline processes 10,000 images daily (each takes 45 minutes). How would you optimize for cost and scalability?</strong>
                <br><br>
                <strong>A:</strong> Use AWS Batch. (1) Package image processing application as Docker container. (2) Push to ECR. (3) Create Batch job definition (image, memory, CPU, timeout). (4) Create compute environment (use 70% Spot instances, 30% on-demand for reliability). (5) Create job queue. (6) Submit 10,000 jobs daily. Batch scales EC2 instances (Spot for cost savings) from 0 to 100+ as jobs queue up, back to 0 as jobs complete. Cost: Spot instances at 70% discount vs on-demand. Lambda would timeout (15 min limit < 45 min job), so Batch is correct choice.
            </li>

            <li>
                <strong>Q: Your organization uses Salesforce for CRM. You want to sync Salesforce opportunities to S3 nightly for BI analysis. How would you implement this with minimal code?</strong>
                <br><br>
                <strong>A:</strong> Use AWS AppFlow. (1) Create AppFlow data flow: Salesforce as source, S3 as destination. (2) Configure trigger: nightly at 11 PM. (3) Mapping: select Opportunity fields to replicate. (4) AppFlow automatically syncs every night—no custom integration code needed. Data lands in S3, ready for BI tools (Redshift, Tableau). Alternative: custom Lambda + Salesforce API (more code), but AppFlow is simpler for this use case.
            </li>
        </ol>

        <hr class="soft-divide">
        <h2>Best Practices & Architecture Patterns</h2>
        <ul>
            <li><strong>Infrastructure as Code:</strong> Always use CloudFormation (or Terraform) for production infrastructure. Never manually create resources. Version control templates, track changes in Git.</li>
            <li><strong>Cost Optimization:</strong> Use Cost Explorer to identify expensive services. Use Anomaly Detection to catch billing surprises. Use Instance Scheduler for dev/test cost savings.</li>
            <li><strong>Automated Operations:</strong> Combine SSM Patch Manager + Maintenance Windows for automated patching. SSM Automation for routine maintenance (snapshots, AMI creation, remediation).</li>
            <li><strong>Secure Access:</strong> Use SSM Session Manager instead of SSH bastion hosts. No port 22 exposure, full audit trail.</li>
            <li><strong>Batch Processing:</strong> Use AWS Batch for compute-intensive, long-running jobs. Use Spot instances for cost savings. Lambda for short, event-triggered functions.</li>
            <li><strong>SaaS Integration:</strong> Use AppFlow for integration with Salesforce, SAP, Zendesk. No custom code, scheduled syncs.</li>
            <li><strong>Development Workflow:</strong> Use Amplify for rapid full-stack web/mobile app deployment. Git-based CI/CD, hosting, backend services integrated.</li>
        </ul>

        <hr class="soft-divide">
        <h2>Closing Notes</h2>
        <p>This section covered essential AWS services for operational excellence, cost optimization, and infrastructure automation. CloudFormation is foundational for infrastructure-as-code. SSM tools (Session Manager, Run Command, Patch Manager, Automation) enable secure, scalable operations without manual server access. Cost Explorer and Instance Scheduler optimize spending. Batch handles long-running compute jobs. AppFlow eliminates integration code. Amplify accelerates web/mobile app development. These services transform how architects design and operate AWS infrastructure—moving from manual, error-prone processes to automated, version-controlled, cost-optimized operations. Master these services for exam success and real-world application deployment.</p>

    </div>
</body>
</html>